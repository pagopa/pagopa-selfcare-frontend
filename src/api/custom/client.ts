/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import {withoutUndefinedValues} from "@pagopa/ts-commons/lib/types";
import {
  createFetchRequestForApi,
  ReplaceRequestParams,
  RequestParams,
  TypeofApiCall,
  TypeofApiParams
} from "@pagopa/ts-commons/lib/requests";
import {identity} from "fp-ts/lib/function";

import {updateInstitutionsDefaultDecoder, UpdateInstitutionsT} from "./requestTypes";

// This is a placeholder for undefined when dealing with object keys
// Typescript doesn't perform well when narrowing a union type which includes string and undefined
// (example: "foo" | "bar" | undefined)
// We use this as a placeholder for type parameters indicating "no key"
type __UNDEFINED_KEY = "_____";

export type ApiOperation =
    TypeofApiCall<UpdateInstitutionsT>;

export type ParamKeys = keyof (
    TypeofApiParams<UpdateInstitutionsT>
    );

/**
 * Defines an adapter for TypeofApiCall which omit one or more parameters in the signature
 * @param ApiT the type which defines the operation to expose
 * @param K the parameter to omit. undefined means no parameters will be omitted
 */
export type OmitApiCallParams<
    ApiT,
    K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = (
    op: TypeofApiCall<ApiT>
) => K extends __UNDEFINED_KEY
    ? TypeofApiCall<ApiT>
    : TypeofApiCall<ReplaceRequestParams<ApiT, Omit<RequestParams<ApiT>, K>>>;

/**
 * Defines an adapter for TypeofApiCall which omit one or more parameters in the signature
 * @param ApiT the type which defines the operation to expose
 * @param K the parameter to omit. undefined means no parameters will be omitted
 */
export type WithDefaultsT<
    K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = OmitApiCallParams<
    | UpdateInstitutionsT,
    K
>;

/**
 * Defines a collection of api operations
 * @param K name of the parameters that the Clients masks from the operations
 */
export type Client<
    K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = K extends __UNDEFINED_KEY
    ? {
        readonly updateInstitutions: TypeofApiCall<UpdateInstitutionsT>;
    }
    : {
        readonly updateInstitutions: TypeofApiCall<
            ReplaceRequestParams<
                UpdateInstitutionsT,
                Omit<RequestParams<UpdateInstitutionsT>, K>
            >
        >;
    };

/**
 * Create an instance of a client
 * @param params hash map of parameters thata define the client:
 *  - baseUrl: the base url for every api call (required)
 *  - fetchApi: an implementation of the fetch() web API, depending on the platform (required)
 *  - basePath: optional path to be appended to the baseUrl
 *  - withDefaults: optional adapter to be applied to every operation, to omit some paramenters
 * @returns a collection of api operations
 */
export function createClient<K extends ParamKeys>(params: {
    baseUrl: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fetchApi: typeof fetch;
    withDefaults: WithDefaultsT<K>;
    basePath?: string;
}): Client<K>;
export function createClient(params: {
    baseUrl: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fetchApi: typeof fetch;
    withDefaults?: undefined;
    basePath?: string;
}): Client;
export function createClient<K extends ParamKeys>({
                                                      baseUrl,
                                                      // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                                      fetchApi,
                                                      withDefaults,
                                                      basePath = "/"
                                                  }: {
    baseUrl: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fetchApi: typeof fetch;
    withDefaults?: WithDefaultsT<K>;
    basePath?: string;
}) {
    const options = {
        baseUrl,
        fetchApi
    };

    const updateInstitutionsT: ReplaceRequestParams<
        UpdateInstitutionsT,
        RequestParams<UpdateInstitutionsT>
    > = {
        method: "post",

        // There is a well-known issue about fetch and Content-Type header when it comes to add multipart/form-data files.
        //  reference: https://github.com/github/fetch/issues/505#issuecomment-293064470
        // The solution is to skip the Content-Type header and let fetch add it for us.
        // @ts-ignore as IRequestType would require something
        headers: ({["JWT"]: JWT}) => ({
            Authorization: `Bearer ${JWT}`
        }),
        response_decoder: updateInstitutionsDefaultDecoder(),
        url: ({}) => `${basePath}/notice/institutions/data`,

        body: ({["body"]: body, ["file"]: file}) => {
            if (typeof window === "undefined")
                throw new Error(
                    "File upload is only support inside a browser runtime envoronment"
                );
            const formData = new FormData();
            formData.append("institutions-data", body);
            if (file) {
                formData.append("file", file);
            }
            return formData;
        },

        query: () => withoutUndefinedValues({})
    };
    const updateInstitutions: TypeofApiCall<UpdateInstitutionsT> = createFetchRequestForApi(
        updateInstitutionsT,
        options
    );

    return {
        updateInstitutions: (withDefaults || identity)(updateInstitutions)
    };

}
